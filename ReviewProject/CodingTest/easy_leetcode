1.EASY
1\Two Sum
通用思路:
（1）O(nlogn)。排序，然后两个指针一前一后。因为题中说明了只有一对答案，因此不需要考虑重复的情况。
（2）O(n)。哈希表。将每个数字放在map中，历遍数组，如果出现和数组中的某一个值相加为target的时候，break。这个方法同样适用于多组解的情况。
思路: 循环数组: 对每一个数字,计算差值,在剩余数组(dict存储实现hash查找)查找差值,返回index(类似(2)思路)
时间复杂度:O(n),辅助空间: n

2\Valid Parentheses
题目:只涉及提到的三种符号,看懂题目意思
思路: 栈最典型的应用就是验证配对情况，作为有效的括号，有一个右括号就必定有一个左括号在前面，所以我们可以将左括号都push进栈中，遇到右括号的时候再pop来消掉。这里不用担心连续不同种类左括号的问题，因为有效的括号对最终还是会有紧邻的括号对
其他思路: 用dict匹配查找
时间复杂度:O(n) 辅助空间:n

3\Merge Two Sorted Lists
题目: 两个有序链表
思路: 经典的链表基本操作。维护两个指针对应两个链表，因为一般会以一条链表为基准，比如说l1, 那么如果l1当期那的元素比较小，那么直接移动l1即可，否则将l2当前的元素插入到l1当前元素的前面。总共移动三个指针完成.
时间复杂度是O(m+n),m和n分别是两条链表的长度，空间复杂度是O(1)
注意: 插入后,l2.next就变了,不再是l2的next了

4\Maximum Subarray
问题: 标准动态规划问题,求解最大子串
思路: 遍历数组,求解每一个位置的局部最大值,最终对所有局部最大值获取全局最大值,此全局最大值的位置即为最大子串
注意: 比较大小的两个数, 当前位置数与局部最大值与其相加结果比较
时间复杂度: O(n), 辅助空间: n

5\Climbing Stairs
三种思路:  http://blog.csdn.net/coder_orz/article/details/51506414
思路: 动态规划问题: 设当前有n个台阶, 可供选择的走法分为
若先跨一个台阶,剩余n-1阶
若先跨两个台阶, 剩余n-2个台阶
所以,n个台阶的不同走法=n-1阶+n-2阶走法数, 规律知就是斐波那契数列
此题,若使用递归复杂度会很大, 一般动态规划使用辅助空间记录历史数据即可
时间复杂度: O(n), 辅助空间: n

6\Symmetric Tree
问题: 判断对称树, 一般涉及树基本使用递归. 题目提示有两个思路去解
思路: 题目很直观, 判断左右子树是否对称:
(1)recursive的解法: 左子树的左子树根和右子树的右子树根是否一致, 左子树的右子树根和右子树的左子树根是否一致. 递归判断即可
停止条件: left==None and right==None
判断: left.val==right.val, 然后比较: left.left == right.right and left.right= right.left(递归)
时间复杂度: nlogn  辅助空间: 0
(2)iterative的解法需要用两个stack去存node: 用两个stack存储left和right(存储和上面一样),当stack非空,将node出栈,依次往下取left和right进行比较即可. 其实就是上面递归利用栈实现非递归解决问题

7\Maximum Depth of Binary Tree
题目: 求二叉树深度
思路: DFS及BFS求解, 递归与非递归，动态规划问题
递归：用DFS
非递归：BFS广度遍历实现，BFS遍历过程，深度在每一次遍历完一层加１（while里面，每次pop出一个root，对root下所有左右子树遍历完（层次遍历）才是一次while循环）
class Solution(object):
    def getMaxDept(self,root):
        if not root:
            return 0
        queues = []
        count = 0
        queues.append(root)
        while len(queues) != 0:
            queues_len = len(queues)
            for i in range(queues_len):
                roots = queues.pop(0)
                if roots.left:
                    queues.append(roots.left)
                if roots.right:
                    queues.append(roots.right)
            count += 1
        return count

    def maxDepth(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        return self.getMaxDept(root)

８\Convert Sorted Array to Binary Search Tree
题目：将一个排序好的数组转化为一颗二叉查找树，且此树要求是平衡的
思路：因为数组已经排好序且要达到平衡，可以用二分法构造．开始取中间点为root节点，左边就是左子树（左子树同理），右边是右子树．递归构造

９\Balanced Binary Tree
题目：判断是否为平衡树，根据定义：左右子树深度之差绝对值不超过１
思路：最外层定义递归函数检查root的左右子树深度之差，然后再定义一个函数求解给定root下子树的深度